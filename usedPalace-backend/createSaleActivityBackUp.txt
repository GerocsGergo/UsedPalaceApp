package com.example.usedpalace.profilemenus

import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.drawable.BitmapDrawable
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.EditText
import android.widget.ImageView
import android.widget.Spinner
import android.widget.Toast
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import com.example.usedpalace.CreateSaleRequest
import com.example.usedpalace.MainMenuActivity
import com.example.usedpalace.R
import com.example.usedpalace.ResponseMessage
import com.example.usedpalace.ResponseMessageWithFolder
import com.example.usedpalace.UserSession
import network.ApiService
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.MultipartBody
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.asRequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.io.File

class CreateSaleActivity : AppCompatActivity() {

    private lateinit var bigCategorySpinner: Spinner
    private lateinit var smallCategorySpinner: Spinner
    private lateinit var inputSaleName: EditText
    private lateinit var inputDesc: EditText
    private lateinit var inputCost: EditText
    private lateinit var createSaleButton: Button
    private lateinit var retrofit: Retrofit
    private lateinit var apiService: ApiService
    private lateinit var image1: ImageView
    private lateinit var image2: ImageView
    private lateinit var image3: ImageView
    private lateinit var image4: ImageView
    private lateinit var image5: ImageView
    private lateinit var imageUri: Uri

    private val contract = registerForActivityResult(ActivityResultContracts.GetContent()){
        imageUri = it!!
        image1.setImageURI(it)
    }
    private val contract2 = registerForActivityResult(ActivityResultContracts.GetContent()){
        imageUri = it!!
        image2.setImageURI(it)
    }
    private val contract3 = registerForActivityResult(ActivityResultContracts.GetContent()){
        imageUri = it!!
        image3.setImageURI(it)
    }
    private val contract4 = registerForActivityResult(ActivityResultContracts.GetContent()){
        imageUri = it!!
        image4.setImageURI(it)
    }
    private val contract5 = registerForActivityResult(ActivityResultContracts.GetContent()){
        imageUri = it!!
        image5.setImageURI(it)
    }




    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContentView(R.layout.activity_create_sale)
        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }

        val buttonBack: Button = findViewById(R.id.buttonBack)
        buttonBack.setOnClickListener {
            navigateBackToProfile()
        }

        // Initialize Spinners
        bigCategorySpinner = findViewById(R.id.mainCategory)
        smallCategorySpinner = findViewById(R.id.subCategory)

        // Set up Big Category Spinner
        ArrayAdapter.createFromResource(
            this,
            R.array.big_categories,
            android.R.layout.simple_spinner_item
        ).also { adapter ->
            adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            bigCategorySpinner.adapter = adapter
        }

        // Handle category selection changes
        bigCategorySpinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>, view: View?, position: Int, id: Long) {
                if (position > 0) { // Skip the first "Select" item
                    updateSubcategories(position)
                } else {
                    smallCategorySpinner.adapter = null // Clear subcategories
                }
            }

            override fun onNothingSelected(parent: AdapterView<*>) {}
        }

        retrofit = Retrofit.Builder()
            .baseUrl("http://10.0.2.2:3000/") // Use 10.0.2.2 for localhost in Android emulator
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        apiService = retrofit.create(ApiService::class.java)


        inputSaleName = findViewById(R.id.inputSaleName)
        inputDesc = findViewById(R.id.inputDesc)
        inputCost = findViewById(R.id.inputCost)
        createSaleButton = findViewById(R.id.createSale)

        //TODO UPLOAD PIC BUTTONS AND PIC UPLOADING
        image1 = findViewById(R.id.image1)
        image1.setOnClickListener {
            contract.launch("image/*")
        }
        image2 = findViewById(R.id.image2)
        image2.setOnClickListener {
            contract2.launch("image/*")
        }
        image3 = findViewById(R.id.image3)
        image3.setOnClickListener {
            contract3.launch("image/*")
        }
        image4 = findViewById(R.id.image4)
        image4.setOnClickListener {
            contract4.launch("image/*")
        }
        image5 = findViewById(R.id.image5)
        image5.setOnClickListener {
            contract5.launch("image/*")
        }

        createSaleButton.setOnClickListener {
            createSale()
        }

    }

    //For image uploading
//    private fun uploadImage(saleFolder: String?, image: ImageView) {
//
//        if (image.drawable.equals("base_line_add_24") || image.drawable == null) {
//            return
//        }
//        if (saleFolder.isNullOrEmpty()) {
//            return
//        }
//    }


    private fun uploadImageWithRetrofit(saleFolder: String, imageView: ImageView, imageIndex: Int) {
        // Skip if showing the default add icon
        if (isDefaultAddIcon(imageView)) {
            Log.d("UploadImage", "Skipping upload for image$imageIndex - default add icon")
            return
        }

        try {
            val uri = imageView.tag as? Uri
            if (uri != null) {
                uploadUriWithRetrofit(saleFolder, uri, imageIndex)
            } else {
                val bitmap = getBitmapFromImageView(imageView)
                bitmap?.let {
                    uploadBitmapWithRetrofit(saleFolder, it, imageIndex)
                }
            }
        } catch (e: Exception) {
            Log.e("UploadImage", "Retrofit upload failed: ${e.message}")
        }
    }

    // Helper function to check if ImageView has the default add icon
    private fun isDefaultAddIcon(imageView: ImageView): Boolean {
        return if (imageView.drawable != null) {
            // Compare the constant name of the drawable
            imageView.drawable.constantState?.toString()?.contains("baseline_add_24") == true
        } else {
            true // Consider null drawable as default
        }
    }

    private fun uploadUriWithRetrofit(saleFolder: String, uri: Uri, imageIndex: Int) {
        val file = createFileFromUri(uri) ?: return

        uploadFileWithRetrofit(saleFolder, file, imageIndex) {
            file.delete() // Clean up temp file
        }
    }

    private fun uploadBitmapWithRetrofit(saleFolder: String, bitmap: Bitmap, imageIndex: Int) {
        val file = createTempImageFile(this, bitmap)
        uploadFileWithRetrofit(saleFolder, file, imageIndex) {
            file.delete() // Clean up temp file
        }
    }

    private fun uploadFileWithRetrofit(saleFolder: String, file: File, imageIndex: Int, onComplete: () -> Unit) {
        // Prepare multipart request
        val requestFile = file.asRequestBody("image/*".toMediaTypeOrNull())

        // Create MultipartBody.Part for the image
        val imagePart = MultipartBody.Part.createFormData(
            "image",
            file.name,
            requestFile
        )

        // Create RequestBody parts for the other fields
        val saleFolderPart = MultipartBody.Part.createFormData(
            "saleFolder",
            saleFolder
        )

        val imageIndexPart = MultipartBody.Part.createFormData(
            "imageIndex",
            imageIndex.toString()
        )

        // Make the API call
        apiService.uploadImage(saleFolderPart, imageIndexPart, imagePart).enqueue(object : Callback<ResponseMessage> {
            override fun onResponse(call: Call<ResponseMessage>, response: Response<ResponseMessage>) {
                if (!response.isSuccessful) {
                    Log.e("UploadImage", "Retrofit upload failed: ${response.errorBody()?.string()}")
                }
                onComplete()
            }

            override fun onFailure(call: Call<ResponseMessage>, t: Throwable) {
                Log.e("UploadImage", "Retrofit upload error: ${t.message}")
                onComplete()
            }
        })
    }

    private fun createFileFromUri(uri: Uri): File? {
        return try {
            val tempFile = File.createTempFile("upload_", ".jpg", cacheDir)
            contentResolver.openInputStream(uri)?.use { input ->
                tempFile.outputStream().use { output ->
                    input.copyTo(output)
                }
            }
            tempFile
        } catch (e: Exception) {
            Log.e("UploadImage", "Error creating file from URI: ${e.message}")
            null
        }
    }

    private fun getBitmapFromImageView(imageView: ImageView): Bitmap? {
        val drawable = imageView.drawable
        return if (drawable is BitmapDrawable) {
            drawable.bitmap
        } else {
            // Handle VectorDrawable or other types (convert to Bitmap)
            val bitmap = Bitmap.createBitmap(
                drawable.intrinsicWidth,
                drawable.intrinsicHeight,
                Bitmap.Config.ARGB_8888
            )
            val canvas = Canvas(bitmap)
            drawable.setBounds(0, 0, canvas.width, canvas.height)
            drawable.draw(canvas)
            bitmap
        }
    }

    private fun createTempImageFile(context: Context, bitmap: Bitmap): File {
        // Create a temporary file in the app's cache directory
        val file = File.createTempFile(
            "upload_${System.currentTimeMillis()}",
            ".jpg",
            context.cacheDir
        )
        file.outputStream().use { outputStream ->
            bitmap.compress(Bitmap.CompressFormat.JPEG, 85, outputStream)
        }
        return file
    }




    //For creating sales
    private fun createSale() {
        val name = inputSaleName.text.toString().trim()
        val description = inputDesc.text.toString().trim()
        val costText = inputCost.text.toString().trim()
        val cost = try {
            inputCost.text.toString().toInt()  // Convert to Int
        } catch (e: NumberFormatException) {
            // Handle invalid input, but it wont be hehe
            Toast.makeText(this, "Please enter a valid number", Toast.LENGTH_SHORT).show()
            return
        }

        val (bigCategory, smallCategory) = getSelectedCategories()

        if (bigCategory == null) {
            Toast.makeText(this, "Please select a main category", Toast.LENGTH_SHORT).show()
            return
        }

        // Validate inputs
        if (name.isEmpty() || description.isEmpty() || costText.isEmpty()) {
            Toast.makeText(this, "Please fill all required fields", Toast.LENGTH_SHORT).show()
            return
        }

        // Get current user ID
        val userId = UserSession.getUserId()

        val request = CreateSaleRequest(
            name = name,
            description = description,
            cost = cost,
            bigCategory = bigCategory,
            smallCategory = smallCategory,
            userId = userId
        )

        // Make API call
        apiService.createSale(request).enqueue(object : Callback<ResponseMessageWithFolder> {
            override fun onResponse(call: Call<ResponseMessageWithFolder>, response: Response<ResponseMessageWithFolder>) {
                if (response.isSuccessful) {
                    val message = response.body()?.message
                    Toast.makeText(this@CreateSaleActivity, message, Toast.LENGTH_SHORT).show()
                    val saleFolder = response.body()?.saleFolder

                    saleFolder?.let {

                        uploadImageWithRetrofit(it, image1, 1)
                        uploadImageWithRetrofit(it, image2, 2)
                        uploadImageWithRetrofit(it, image3, 3)
                        uploadImageWithRetrofit(it, image4, 4)
                        uploadImageWithRetrofit(it, image5, 5)
                    }
                    //TODO PIC UPLOADING

                    inputCost.text.clear()
                    inputSaleName.text.clear()
                    inputDesc.text.clear()

                } else {
                    val errorBody = response.errorBody()?.string()
                    Toast.makeText(this@CreateSaleActivity, "Creating sale failed: $errorBody", Toast.LENGTH_SHORT).show()
                }
            }
            override fun onFailure(call: Call<ResponseMessageWithFolder>, t: Throwable) {
                Toast.makeText(this@CreateSaleActivity, "Error: ${t.message}", Toast.LENGTH_SHORT).show()
            }
        })
    }




    //For spinners and categories
    private fun updateSubcategories(categoryPosition: Int) {
        val subcategoryArray = when (categoryPosition) {
            1 -> R.array.book_subcategories
            2 -> R.array.dvd_subcategories
            3 -> R.array.bluray_subcategories
            4 -> R.array.cd_subcategories
            5 -> R.array.console_subcategories
            6 -> R.array.games_subcategories

            else -> -1
        }

        if (subcategoryArray != -1) {
            ArrayAdapter.createFromResource(
                this,
                subcategoryArray,
                android.R.layout.simple_spinner_item
            ).also { adapter ->
                adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
                smallCategorySpinner.adapter = adapter
            }
        } else {
            smallCategorySpinner.adapter = null
        }
    }

    private fun getSelectedCategories(): Pair<String?, String?> {
        val bigCategory = if (bigCategorySpinner.selectedItemPosition > 0) {
            bigCategorySpinner.selectedItem.toString()
        } else null

        val smallCategory = if (smallCategorySpinner.adapter != null && smallCategorySpinner.selectedItemPosition >= 0) {
            smallCategorySpinner.selectedItem.toString()
        } else null

        return Pair(bigCategory, smallCategory)
    }



    //FOR NAVIGATION
    private fun navigateBackToProfile() {
        // Create an intent to return to MainMenuActivity
        val intent = Intent(this, MainMenuActivity::class.java).apply {
            // Add flag to indicate we want to show ProfileFragment
            putExtra("SHOW_PROFILE_FRAGMENT", true)
            // Clear the activity stack so we don't have multiple MainMenuActivities
            flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_SINGLE_TOP
        }
        startActivity(intent)
        finish() // Close the current SettingsActivity
    }
    // Handle system back button press
    override fun onBackPressed() {
        super.onBackPressed()
        navigateBackToProfile()
    }

}